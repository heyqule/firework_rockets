---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by heyqule.
--- DateTime: 8/30/2022 11:12 PM
---
require 'constant'
local ScriptSharedFunctions = require 'shared'

-- Track all deployed crates with rocket in inventory
-- When create don't have rocket, move to inactive list. x entity/check
-- { "surface.index-x-y" = {"prev", "next",  "entity", "next_tick"} }
local deployed_active_crates = {
    head = nil,
    tail = nil,
    size = 0,
    crates = {},
}

-- Track crates without rocket in inventory, checks every 3s, if it has rockets in inventory, move it back to active list.
-- { "surface.index-x-y" = {"prev", "next",  "entity"}}
local deployed_inactive_crates = {
    head = nil,
    tail = nil,
    size = 0,
    crates = {},
}

local MAX_ACTIVE_PER_BATCH = settings.startup['firework-rocket-mortar-active-batch'].value
local MAX_INACTIVE_PER_BATCH = settings.startup['firework-rocket-mortar-inactive-batch'].value
local MAX_ACTIVE_PROCESS_INTERVAL = settings.startup['firework-rocket-mortar-active-interval'].value
local MORTAR_COOLDOWN = settings.startup['firework-rocket-mortar-cooldown'].value
local inactive_processing_id;
local active_processing_id;

local add_crate = function(crateList, crateKey, crate)
    if crateList.crates[crateKey] then
        return
    end
    crateList.crates[crateKey] = {}

    if not crateList.head then
        crateList.head = crateKey
    end

    crateList.crates[crateKey] = crate

    if crateList.tail then
        if crateList.crates[crateList.tail] then
            crateList.crates[crateList.tail].next = crateKey
        end
        crateList.crates[crateKey].prev = crateList.tail
    end

    crateList.tail = crateKey
    crateList.size = crateList.size + 1
end

local remove_crate = function(crateList, crateKey)
    if not crateList.crates[crateKey] then
        return
    end

    local crate = crateList.crates[crateKey]

    if crateList.head == crateKey then
        crateList.head = crate.next
        if crateList.crates[crate.next] then
            crateList.crates[crate.next].prev = nil
        end
        crateList.crates[crateKey] = nil
    elseif crateList.tail == crateKey then
        crateList.tail = crate.prev
        crateList.crates[crateKey] = nil
        if crateList.crates[crate.prev] then
            crateList.crates[crate.prev].next = nil
        end
    else
        crateList.crates[crate.prev].next = crate.next
        crateList.crates[crate.next].prev = crate.prev
        crateList.crates[crateKey] = nil
    end

    crateList.size = crateList.size - 1
    if crateList.size == 0 then
        crateList.head = nil
        crateList.tail = nil
    end
end

local acceptable_rockets = {
    ['firework-random_rocket'] = RANDOM_ROCKET_EFFECT_ID,
    ['firework-colorful_rocket'] = COLORFUL_ROCKET_EFFECT_ID,
    ['firework-cool_rocket'] = COOL_ROCKET_EFFECT_ID,
    ['firework-warm_rocket'] = WARM_ROCKET_EFFECT_ID,
    ['firework-small_rocket'] = SMALL_ROCKET_EFFECT_ID,
    ['firework-large_rocket'] = LARGE_ROCKET_EFFECT_ID,
    ['firework-flare_rocket'] = FLARE_ROCKET_EFFECT_ID,
}

local statistics = {}

local on_created_entity = function(event)
    local entity = event.entity
    if not (entity and entity.valid and entity.name == 'firework-mortar_crate') then return end
    add_crate(deployed_inactive_crates, entity.unit_number, {
        entity = entity,
    })
end

local on_entity_removed = function(event)
    local entity = event.entity
    if not (entity and entity.valid and entity.name == 'firework-mortar_crate') then return end

    local key = entity.unit_number
    remove_crate(deployed_inactive_crates, key)
    remove_crate(deployed_active_crates, key)
end

local add_statistic = function(entity, item_name, count)
    local force = entity.force;
    if force then
        if statistics[force.name..entity.surface.index] == nil then
            statistics[force.name..entity.surface.index] = force.get_item_production_statistics(entity.surface)
        end
        statistics[force.name..entity.surface.index].on_flow(item_name, count * -1)
    end
end

local pick_new_active_id = function()
    if not active_processing_id then
        active_processing_id = deployed_active_crates.head
        return
    end

    local turret = deployed_active_crates.crates[active_processing_id]
    if turret and turret.next then
        active_processing_id = turret.next
    elseif deployed_active_crates.head then
        active_processing_id = deployed_active_crates.head
    else
        active_processing_id = nil
    end
end

local process_active_crates = function(event)
    for i = 0, MAX_ACTIVE_PER_BATCH do
        pick_new_active_id()

        local turret = deployed_active_crates.crates[active_processing_id]
        if not turret then
            break;
        end
        if event.tick < turret.next_tick then
            goto process_active_crates_for_continue
        end

        local entity = turret.entity
        if not (entity and entity.valid) or entity.status ~= defines.entity_status.working then
            remove_crate(deployed_active_crates, active_processing_id)
            add_crate(deployed_inactive_crates, active_processing_id, {
                entity = turret.entity
            })
            goto process_active_crates_for_continue
        end
        
        local max_range
        local inventory = entity.get_inventory(defines.inventory.turret_ammo)
        local contents = inventory.get_contents()
        local fired = false
        for _, data in pairs(contents) do
            if acceptable_rockets[data.name] and data.count > 0
            then
                local next_fire_interval = math.ceil(MORTAR_COOLDOWN * math.random(0.8, 1.2))
                
                -- get mortar crate signal to determine the shooting timer
                local time_signal = entity.get_signal({name=MORTAR_CRATE_SIGNAL, type='item'},defines.wire_connector_id.circuit_red,defines.wire_connector_id.circuit_green)
                if time_signal > 0 then
                        -- The minimum value is "Active Mortar Process Interval" settings, since it won't run lower than that interval.
                        next_fire_interval = time_signal
                end
                -- get rocket specific signal to determine the shooting range
                local range_signal = entity.get_signal({name=data.name, type='item'}, defines.wire_connector_id.circuit_red,defines.wire_connector_id.circuit_green)
                if range_signal > 0 then
                    max_range = math.max(math.min(range_signal,100),8)
                end

                ScriptSharedFunctions.create_firework(
                        entity.surface.index,
                        entity.position,
                        acceptable_rockets[data.name],
                        entity,
                        nil,
                        max_range
                )
                inventory.remove({name=data.name,count=1})
                add_statistic(entity, data.name, 1)
                turret.next_tick = event.tick + next_fire_interval
                fired = true
            end
        end

        if not fired and turret.failed == 3 then
            add_crate(deployed_inactive_crates, active_processing_id, {
                entity = turret.entity
            })
            remove_crate(deployed_active_crates, active_processing_id)
        end
        ::process_active_crates_for_continue::
    end
end

local pick_new_inactive_id = function()
    if not inactive_processing_id then
        inactive_processing_id = deployed_inactive_crates.head
        return
    end

    local turret = deployed_inactive_crates.crates[inactive_processing_id]
    if turret and turret.next then
        inactive_processing_id = turret.next
    elseif deployed_inactive_crates.head then
        inactive_processing_id = deployed_inactive_crates.head
    else
        inactive_processing_id = nil
    end
end

local process_inactive_crates = function(event)
    for i = 0, MAX_INACTIVE_PER_BATCH do
        pick_new_inactive_id()
        local turret = deployed_inactive_crates.crates[inactive_processing_id]

        if not turret then
            break;
        end

        local entity = turret.entity
        if not (entity and entity.valid) then
            remove_crate(deployed_inactive_crates, inactive_processing_id)
            goto process_inactive_crates_for_continue
        end
        local inventory = entity.get_inventory(defines.inventory.turret_ammo)
        local contents = inventory.get_contents()
        
        for _, data in pairs(contents) do
            if acceptable_rockets[data.name] and data.count > 0 and
               entity.status == defines.entity_status.working
            then
                add_crate(deployed_active_crates, inactive_processing_id, {
                    entity = turret.entity,
                    next_tick = event.tick + MAX_ACTIVE_PROCESS_INTERVAL
                })
                remove_crate(deployed_inactive_crates, inactive_processing_id)
            end
        end

        ::process_inactive_crates_for_continue::
    end
end

local mortar_crate = {}

mortar_crate.events =
{
    [defines.events.on_built_entity] = on_created_entity,
    [defines.events.on_robot_built_entity] = on_created_entity,
    [defines.events.script_raised_built] = on_created_entity,
    [defines.events.script_raised_revive] = on_created_entity,
    [defines.events.on_entity_cloned] = on_created_entity,
    [defines.events.on_space_platform_built_entity] = on_created_entity,

    [defines.events.on_entity_died] = on_entity_removed,
    [defines.events.script_raised_destroy] = on_entity_removed,
    [defines.events.on_player_mined_entity] = on_entity_removed,
    [defines.events.on_robot_mined_entity] = on_entity_removed,
    [defines.events.on_space_platform_mined_entity] = on_entity_removed,
}

mortar_crate.on_nth_tick = {
    [settings.startup['firework-rocket-mortar-active-interval'].value] = process_active_crates,
    [settings.startup['firework-rocket-mortar-inactive-interval'].value] = process_inactive_crates
}
mortar_crate.on_init = function()
    storage.deployed_active_crates = storage.deployed_active_crates or deployed_active_crates
    storage.deployed_inactive_crates = storage.deployed_inactive_crates or deployed_inactive_crates
end

mortar_crate.on_load = function()
    deployed_active_crates = storage.deployed_active_crates or deployed_active_crates
    deployed_inactive_crates = storage.deployed_inactive_crates or deployed_inactive_crates
end

mortar_crate.get_debug_data = function()
    print('Processing ID')
    print(tostring(inactive_processing_id) .. '/' .. tostring(active_processing_id))
    print('deployed_active_crates')
    print(tostring(deployed_active_crates.head) .. '/'.. tostring(deployed_active_crates.tail))
    print(deployed_active_crates.size)
    print('deployed_inactive_crates')
    print(tostring(deployed_inactive_crates.head) .. '/'.. tostring(deployed_inactive_crates.tail))
    print(deployed_inactive_crates.size)
    print('storage data:')
    print(serpent.block(storage))
end

mortar_crate.debug_list_inactive_motars = function()
    print('Listing inactive crates')
    print(deployed_inactive_crates.head)
    for key, turret in pairs(deployed_inactive_crates.crates) do
        print(key)
        print(turret.entity.type)
        print(turret.next)
    end
end

return mortar_crate